/* Code generated by codegen/main.go. DO NOT EDIT. */
namespace Nakama
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Threading.Tasks;
    using TinyJson;

    /// <summary>
    /// An exception generated for <c>HttpResponse</c> objects don't return a success status.
    /// </summary>
    public sealed class ApiResponseException : Exception
    {
        public long StatusCode { get; }

        public int GrpcStatusCode { get; }

        public ApiResponseException(long statusCode, string content, int grpcCode) : base(content)
        {
            StatusCode = statusCode;
            GrpcStatusCode = grpcCode;
        }

        public ApiResponseException(string message, Exception e) : base(message, e)
        {
            StatusCode = -1L;
            GrpcStatusCode = -1;
        }

        public ApiResponseException(string content) : this(-1L, content, -1)
        {
        }

        public override string ToString()
        {
            return $"ApiResponseException(StatusCode={StatusCode}, Message='{Message}', GrpcStatusCode={GrpcStatusCode})";
        }
    }

    /// <summary>
    /// A single user-role pair.
    /// </summary>
    public interface IGroupUserListGroupUser
    {

        /// <summary>
        /// Their relationship to the group.
        /// </summary>
        int State { get; }

        /// <summary>
        /// User.
        /// </summary>
        IUser User { get; }
    }

    /// <inheritdoc />
    internal class GroupUserListGroupUser : IGroupUserListGroupUser
    {

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public int State { get; set; }

        /// <inheritdoc />
        public IUser User => _user;
        [DataMember(Name="user"), Preserve]
        public User _user { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "State: ", State, ", ");
            output = string.Concat(output, "User: ", User, ", ");
            return output;
        }
    }

    /// <summary>
    /// A single group-role pair.
    /// </summary>
    public interface IUserGroupListUserGroup
    {

        /// <summary>
        /// Group.
        /// </summary>
        IGroup Group { get; }

        /// <summary>
        /// The user's relationship to the group.
        /// </summary>
        int State { get; }
    }

    /// <inheritdoc />
    internal class UserGroupListUserGroup : IUserGroupListUserGroup
    {

        /// <inheritdoc />
        public IGroup Group => _group;
        [DataMember(Name="group"), Preserve]
        public Group _group { get; set; }

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public int State { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Group: ", Group, ", ");
            output = string.Concat(output, "State: ", State, ", ");
            return output;
        }
    }

    /// <summary>
    /// Record values to write.
    /// </summary>
    public interface IWriteLeaderboardRecordRequestLeaderboardRecordWrite
    {

        /// <summary>
        /// Optional record metadata.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The score value to submit.
        /// </summary>
        string Score { get; }

        /// <summary>
        /// An optional secondary value.
        /// </summary>
        string Subscore { get; }
    }

    /// <inheritdoc />
    internal class WriteLeaderboardRecordRequestLeaderboardRecordWrite : IWriteLeaderboardRecordRequestLeaderboardRecordWrite
    {

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="score"), Preserve]
        public string Score { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subscore"), Preserve]
        public string Subscore { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "Score: ", Score, ", ");
            output = string.Concat(output, "Subscore: ", Subscore, ", ");
            return output;
        }
    }

    /// <summary>
    /// Record values to write.
    /// </summary>
    public interface IWriteTournamentRecordRequestTournamentRecordWrite
    {

        /// <summary>
        /// A JSON object of additional properties (optional).
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The score value to submit.
        /// </summary>
        string Score { get; }

        /// <summary>
        /// An optional secondary value.
        /// </summary>
        string Subscore { get; }
    }

    /// <inheritdoc />
    internal class WriteTournamentRecordRequestTournamentRecordWrite : IWriteTournamentRecordRequestTournamentRecordWrite
    {

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="score"), Preserve]
        public string Score { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subscore"), Preserve]
        public string Subscore { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "Score: ", Score, ", ");
            output = string.Concat(output, "Subscore: ", Subscore, ", ");
            return output;
        }
    }

    /// <summary>
    /// A user with additional account details. Always the current user.
    /// </summary>
    public interface IApiAccount
    {

        /// <summary>
        /// The custom id in the user's account.
        /// </summary>
        string CustomId { get; }

        /// <summary>
        /// The devices which belong to the user's account.
        /// </summary>
        IEnumerable<IAccountDevice> Devices { get; }

        /// <summary>
        /// The email address of the user.
        /// </summary>
        string Email { get; }

        /// <summary>
        /// The user object.
        /// </summary>
        IUser User { get; }

        /// <summary>
        /// The UNIX time when the user's email was verified.
        /// </summary>
        string VerifyTime { get; }

        /// <summary>
        /// The user's wallet data.
        /// </summary>
        string Wallet { get; }
    }

    /// <inheritdoc />
    internal class ApiAccount : IApiAccount
    {

        /// <inheritdoc />
        [DataMember(Name="custom_id"), Preserve]
        public string CustomId { get; set; }

        /// <inheritdoc />
        public IEnumerable<IAccountDevice> Devices => _devices ?? new List<AccountDevice>(0);
        [DataMember(Name="devices"), Preserve]
        public List<AccountDevice> _devices { get; set; }

        /// <inheritdoc />
        [DataMember(Name="email"), Preserve]
        public string Email { get; set; }

        /// <inheritdoc />
        public IUser User => _user;
        [DataMember(Name="user"), Preserve]
        public User _user { get; set; }

        /// <inheritdoc />
        [DataMember(Name="verify_time"), Preserve]
        public string VerifyTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="wallet"), Preserve]
        public string Wallet { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CustomId: ", CustomId, ", ");
            output = string.Concat(output, "Devices: [", string.Join(", ", Devices), "], ");
            output = string.Concat(output, "Email: ", Email, ", ");
            output = string.Concat(output, "User: ", User, ", ");
            output = string.Concat(output, "VerifyTime: ", VerifyTime, ", ");
            output = string.Concat(output, "Wallet: ", Wallet, ", ");
            return output;
        }
    }

    /// <summary>
    /// Send a custom ID to the server. Used with authenticate/link/unlink.
    /// </summary>
    public interface IApiAccountCustom
    {

        /// <summary>
        /// A custom identifier.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountCustom : IApiAccountCustom
    {

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Id: ", Id, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// Send a device to the server. Used with authenticate/link/unlink and user.
    /// </summary>
    public interface IApiAccountDevice
    {

        /// <summary>
        /// A device identifier. Should be obtained by a platform-specific device API.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountDevice : IApiAccountDevice
    {

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Id: ", Id, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// Send an email with password to the server. Used with authenticate/link/unlink.
    /// </summary>
    public interface IApiAccountEmail
    {

        /// <summary>
        /// A valid RFC-5322 email address.
        /// </summary>
        string Email { get; }

        /// <summary>
        /// A password for the user account.
        /// </summary>
        string Password { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountEmail : IApiAccountEmail
    {

        /// <inheritdoc />
        [DataMember(Name="email"), Preserve]
        public string Email { get; set; }

        /// <inheritdoc />
        [DataMember(Name="password"), Preserve]
        public string Password { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Email: ", Email, ", ");
            output = string.Concat(output, "Password: ", Password, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// Send a Facebook token to the server. Used with authenticate/link/unlink.
    /// </summary>
    public interface IApiAccountFacebook
    {

        /// <summary>
        /// The OAuth token received from Facebook to access their profile API.
        /// </summary>
        string Token { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountFacebook : IApiAccountFacebook
    {

        /// <inheritdoc />
        [DataMember(Name="token"), Preserve]
        public string Token { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Token: ", Token, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
    /// </summary>
    public interface IApiAccountGameCenter
    {

        /// <summary>
        /// Bundle ID (generated by GameCenter).
        /// </summary>
        string BundleId { get; }

        /// <summary>
        /// Player ID (generated by GameCenter).
        /// </summary>
        string PlayerId { get; }

        /// <summary>
        /// The URL for the public encryption key.
        /// </summary>
        string PublicKeyUrl { get; }

        /// <summary>
        /// A random "NSString" used to compute the hash and keep it randomized.
        /// </summary>
        string Salt { get; }

        /// <summary>
        /// The verification signature data generated.
        /// </summary>
        string Signature { get; }

        /// <summary>
        /// Time since UNIX epoch when the signature was created.
        /// </summary>
        string TimestampSeconds { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountGameCenter : IApiAccountGameCenter
    {

        /// <inheritdoc />
        [DataMember(Name="bundle_id"), Preserve]
        public string BundleId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="player_id"), Preserve]
        public string PlayerId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="public_key_url"), Preserve]
        public string PublicKeyUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="salt"), Preserve]
        public string Salt { get; set; }

        /// <inheritdoc />
        [DataMember(Name="signature"), Preserve]
        public string Signature { get; set; }

        /// <inheritdoc />
        [DataMember(Name="timestamp_seconds"), Preserve]
        public string TimestampSeconds { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "BundleId: ", BundleId, ", ");
            output = string.Concat(output, "PlayerId: ", PlayerId, ", ");
            output = string.Concat(output, "PublicKeyUrl: ", PublicKeyUrl, ", ");
            output = string.Concat(output, "Salt: ", Salt, ", ");
            output = string.Concat(output, "Signature: ", Signature, ", ");
            output = string.Concat(output, "TimestampSeconds: ", TimestampSeconds, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// Send a Google token to the server. Used with authenticate/link/unlink.
    /// </summary>
    public interface IApiAccountGoogle
    {

        /// <summary>
        /// The OAuth token received from Google to access their profile API.
        /// </summary>
        string Token { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountGoogle : IApiAccountGoogle
    {

        /// <inheritdoc />
        [DataMember(Name="token"), Preserve]
        public string Token { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Token: ", Token, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// Send a Steam token to the server. Used with authenticate/link/unlink.
    /// </summary>
    public interface IApiAccountSteam
    {

        /// <summary>
        /// The account token received from Steam to access their profile API.
        /// </summary>
        string Token { get; }

        /// <summary>
        /// Extra information that will be bundled in the session token.
        /// </summary>
        IDictionary<string, string> Vars { get; }
    }

    /// <inheritdoc />
    internal class ApiAccountSteam : IApiAccountSteam
    {

        /// <inheritdoc />
        [DataMember(Name="token"), Preserve]
        public string Token { get; set; }

        /// <inheritdoc />
        public IDictionary<string, string> Vars => _vars ?? new Dictionary<string, string>();
        [DataMember(Name="vars"), Preserve]
        public Dictionary<string, string> _vars { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Token: ", Token, ", ");

            var mapString = "";
            foreach (var kvp in Vars)
            {
                mapString = string.Concat(mapString, "{" + kvp.Key + "=" + kvp.Value + "}");
            }
            output = string.Concat(output, "Vars: [" + mapString + "]");
            return output;
        }
    }

    /// <summary>
    /// A message sent on a channel.
    /// </summary>
    public interface IApiChannelMessage
    {

        /// <summary>
        /// The channel this message belongs to.
        /// </summary>
        string ChannelId { get; }

        /// <summary>
        /// The code representing a message type or category.
        /// </summary>
        int Code { get; }

        /// <summary>
        /// The content payload.
        /// </summary>
        string Content { get; }

        /// <summary>
        /// The UNIX time when the message was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The ID of the group, or an empty string if this message was not sent through a group channel.
        /// </summary>
        string GroupId { get; }

        /// <summary>
        /// The unique ID of this message.
        /// </summary>
        string MessageId { get; }

        /// <summary>
        /// True if the message was persisted to the channel's history, false otherwise.
        /// </summary>
        bool Persistent { get; }

        /// <summary>
        /// The name of the chat room, or an empty string if this message was not sent through a chat room.
        /// </summary>
        string RoomName { get; }

        /// <summary>
        /// Message sender, usually a user ID.
        /// </summary>
        string SenderId { get; }

        /// <summary>
        /// The UNIX time when the message was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
        /// </summary>
        string UserIdOne { get; }

        /// <summary>
        /// The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
        /// </summary>
        string UserIdTwo { get; }

        /// <summary>
        /// The username of the message sender, if any.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ApiChannelMessage : IApiChannelMessage
    {

        /// <inheritdoc />
        [DataMember(Name="channel_id"), Preserve]
        public string ChannelId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public int Code { get; set; }

        /// <inheritdoc />
        [DataMember(Name="content"), Preserve]
        public string Content { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="group_id"), Preserve]
        public string GroupId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="message_id"), Preserve]
        public string MessageId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="persistent"), Preserve]
        public bool Persistent { get; set; }

        /// <inheritdoc />
        [DataMember(Name="room_name"), Preserve]
        public string RoomName { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sender_id"), Preserve]
        public string SenderId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id_one"), Preserve]
        public string UserIdOne { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id_two"), Preserve]
        public string UserIdTwo { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "ChannelId: ", ChannelId, ", ");
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Content: ", Content, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "GroupId: ", GroupId, ", ");
            output = string.Concat(output, "MessageId: ", MessageId, ", ");
            output = string.Concat(output, "Persistent: ", Persistent, ", ");
            output = string.Concat(output, "RoomName: ", RoomName, ", ");
            output = string.Concat(output, "SenderId: ", SenderId, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserIdOne: ", UserIdOne, ", ");
            output = string.Concat(output, "UserIdTwo: ", UserIdTwo, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of channel messages, usually a result of a list operation.
    /// </summary>
    public interface IApiChannelMessageList
    {

        /// <summary>
        /// A list of messages.
        /// </summary>
        IEnumerable<IChannelMessage> Messages { get; }

        /// <summary>
        /// The cursor to send when retireving the next page, if any.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page, if any.
        /// </summary>
        string PrevCursor { get; }
    }

    /// <inheritdoc />
    internal class ApiChannelMessageList : IApiChannelMessageList
    {

        /// <inheritdoc />
        public IEnumerable<IChannelMessage> Messages => _messages ?? new List<ChannelMessage>(0);
        [DataMember(Name="messages"), Preserve]
        public List<ChannelMessage> _messages { get; set; }

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Messages: [", string.Join(", ", Messages), "], ");
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            return output;
        }
    }

    /// <summary>
    /// Create a group with the current user as owner.
    /// </summary>
    public interface IApiCreateGroupRequest
    {

        /// <summary>
        /// A URL for an avatar image.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// A description for the group.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// The language expected to be a tag which follows the BCP-47 spec.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// Maximum number of group members.
        /// </summary>
        int MaxCount { get; }

        /// <summary>
        /// A unique name for the group.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Mark a group as open or not where only admins can accept members.
        /// </summary>
        bool Open { get; }
    }

    /// <inheritdoc />
    internal class ApiCreateGroupRequest : IApiCreateGroupRequest
    {

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="description"), Preserve]
        public string Description { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_count"), Preserve]
        public int MaxCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="name"), Preserve]
        public string Name { get; set; }

        /// <inheritdoc />
        [DataMember(Name="open"), Preserve]
        public bool Open { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "Description: ", Description, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "MaxCount: ", MaxCount, ", ");
            output = string.Concat(output, "Name: ", Name, ", ");
            output = string.Concat(output, "Open: ", Open, ", ");
            return output;
        }
    }

    /// <summary>
    /// Storage objects to delete.
    /// </summary>
    public interface IApiDeleteStorageObjectId
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The version hash of the object.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiDeleteStorageObjectId : IApiDeleteStorageObjectId
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// Batch delete storage objects.
    /// </summary>
    public interface IApiDeleteStorageObjectsRequest
    {

        /// <summary>
        /// Batch of storage objects.
        /// </summary>
        IEnumerable<IDeleteStorageObjectId> ObjectIds { get; }
    }

    /// <inheritdoc />
    internal class ApiDeleteStorageObjectsRequest : IApiDeleteStorageObjectsRequest
    {

        /// <inheritdoc />
        public IEnumerable<IDeleteStorageObjectId> ObjectIds => _objectIds ?? new List<DeleteStorageObjectId>(0);
        [DataMember(Name="object_ids"), Preserve]
        public List<DeleteStorageObjectId> _objectIds { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "ObjectIds: [", string.Join(", ", ObjectIds), "], ");
            return output;
        }
    }

    /// <summary>
    /// A friend of a user.
    /// </summary>
    public interface IApiFriend
    {

        /// <summary>
        /// The friend status.
        /// </summary>
        int State { get; }

        /// <summary>
        /// The user object.
        /// </summary>
        IUser User { get; }
    }

    /// <inheritdoc />
    internal class ApiFriend : IApiFriend
    {

        /// <inheritdoc />
        [DataMember(Name="state"), Preserve]
        public int State { get; set; }

        /// <inheritdoc />
        public IUser User => _user;
        [DataMember(Name="user"), Preserve]
        public User _user { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "State: ", State, ", ");
            output = string.Concat(output, "User: ", User, ", ");
            return output;
        }
    }

    /// <summary>
    /// A collection of zero or more friends of the user.
    /// </summary>
    public interface IApiFriendList
    {

        /// <summary>
        /// Cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The Friend objects.
        /// </summary>
        IEnumerable<IFriend> Friends { get; }
    }

    /// <inheritdoc />
    internal class ApiFriendList : IApiFriendList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<IFriend> Friends => _friends ?? new List<Friend>(0);
        [DataMember(Name="friends"), Preserve]
        public List<Friend> _friends { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "Friends: [", string.Join(", ", Friends), "], ");
            return output;
        }
    }

    /// <summary>
    /// A group in the server.
    /// </summary>
    public interface IApiGroup
    {

        /// <summary>
        /// A URL for an avatar image.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// The UNIX time when the group was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The id of the user who created the group.
        /// </summary>
        string CreatorId { get; }

        /// <summary>
        /// A description for the group.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// The current count of all members in the group.
        /// </summary>
        int EdgeCount { get; }

        /// <summary>
        /// The id of a group.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// The language expected to be a tag which follows the BCP-47 spec.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// The maximum number of members allowed.
        /// </summary>
        int MaxCount { get; }

        /// <summary>
        /// Additional information stored as a JSON object.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The unique name of the group.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Anyone can join open groups, otherwise only admins can accept members.
        /// </summary>
        bool Open { get; }

        /// <summary>
        /// The UNIX time when the group was last updated.
        /// </summary>
        string UpdateTime { get; }
    }

    /// <inheritdoc />
    internal class ApiGroup : IApiGroup
    {

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="creator_id"), Preserve]
        public string CreatorId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="description"), Preserve]
        public string Description { get; set; }

        /// <inheritdoc />
        [DataMember(Name="edge_count"), Preserve]
        public int EdgeCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_count"), Preserve]
        public int MaxCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="name"), Preserve]
        public string Name { get; set; }

        /// <inheritdoc />
        [DataMember(Name="open"), Preserve]
        public bool Open { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "CreatorId: ", CreatorId, ", ");
            output = string.Concat(output, "Description: ", Description, ", ");
            output = string.Concat(output, "EdgeCount: ", EdgeCount, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "MaxCount: ", MaxCount, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "Name: ", Name, ", ");
            output = string.Concat(output, "Open: ", Open, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            return output;
        }
    }

    /// <summary>
    /// One or more groups returned from a listing operation.
    /// </summary>
    public interface IApiGroupList
    {

        /// <summary>
        /// A cursor used to get the next page.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// One or more groups.
        /// </summary>
        IEnumerable<IGroup> Groups { get; }
    }

    /// <inheritdoc />
    internal class ApiGroupList : IApiGroupList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<IGroup> Groups => _groups ?? new List<Group>(0);
        [DataMember(Name="groups"), Preserve]
        public List<Group> _groups { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "Groups: [", string.Join(", ", Groups), "], ");
            return output;
        }
    }

    /// <summary>
    /// A list of users belonging to a group, along with their role.
    /// </summary>
    public interface IApiGroupUserList
    {

        /// <summary>
        /// Cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// User-role pairs for a group.
        /// </summary>
        IEnumerable<I#/Definitions/GroupUserListGroupUser> GroupUsers { get; }
    }

    /// <inheritdoc />
    internal class ApiGroupUserList : IApiGroupUserList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<I#/Definitions/GroupUserListGroupUser> GroupUsers => _groupUsers ?? new List<#/Definitions/GroupUserListGroupUser>(0);
        [DataMember(Name="group_users"), Preserve]
        public List<#/Definitions/GroupUserListGroupUser> _groupUsers { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "GroupUsers: [", string.Join(", ", GroupUsers), "], ");
            return output;
        }
    }

    /// <summary>
    /// Represents a complete leaderboard record with all scores and associated metadata.
    /// </summary>
    public interface IApiLeaderboardRecord
    {

        /// <summary>
        /// The UNIX time when the leaderboard record was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The UNIX time when the leaderboard record expires.
        /// </summary>
        string ExpiryTime { get; }

        /// <summary>
        /// The ID of the leaderboard this score belongs to.
        /// </summary>
        string LeaderboardId { get; }

        /// <summary>
        /// The maximum number of score updates allowed by the owner.
        /// </summary>
        int MaxNumScore { get; }

        /// <summary>
        /// Metadata.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The number of submissions to this score record.
        /// </summary>
        int NumScore { get; }

        /// <summary>
        /// The ID of the score owner, usually a user or group.
        /// </summary>
        string OwnerId { get; }

        /// <summary>
        /// The rank of this record.
        /// </summary>
        string Rank { get; }

        /// <summary>
        /// The score value.
        /// </summary>
        string Score { get; }

        /// <summary>
        /// An optional subscore value.
        /// </summary>
        string Subscore { get; }

        /// <summary>
        /// The UNIX time when the leaderboard record was updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The username of the score owner, if the owner is a user.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ApiLeaderboardRecord : IApiLeaderboardRecord
    {

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="expiry_time"), Preserve]
        public string ExpiryTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="leaderboard_id"), Preserve]
        public string LeaderboardId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_num_score"), Preserve]
        public int MaxNumScore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="num_score"), Preserve]
        public int NumScore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="owner_id"), Preserve]
        public string OwnerId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="rank"), Preserve]
        public string Rank { get; set; }

        /// <inheritdoc />
        [DataMember(Name="score"), Preserve]
        public string Score { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subscore"), Preserve]
        public string Subscore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "ExpiryTime: ", ExpiryTime, ", ");
            output = string.Concat(output, "LeaderboardId: ", LeaderboardId, ", ");
            output = string.Concat(output, "MaxNumScore: ", MaxNumScore, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "NumScore: ", NumScore, ", ");
            output = string.Concat(output, "OwnerId: ", OwnerId, ", ");
            output = string.Concat(output, "Rank: ", Rank, ", ");
            output = string.Concat(output, "Score: ", Score, ", ");
            output = string.Concat(output, "Subscore: ", Subscore, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
    /// </summary>
    public interface IApiLeaderboardRecordList
    {

        /// <summary>
        /// The cursor to send when retrieving the next page, if any.
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// A batched set of leaderboard records belonging to specified owners.
        /// </summary>
        IEnumerable<ILeaderboardRecord> OwnerRecords { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page, if any.
        /// </summary>
        string PrevCursor { get; }

        /// <summary>
        /// A list of leaderboard records.
        /// </summary>
        IEnumerable<ILeaderboardRecord> Records { get; }
    }

    /// <inheritdoc />
    internal class ApiLeaderboardRecordList : IApiLeaderboardRecordList
    {

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<ILeaderboardRecord> OwnerRecords => _ownerRecords ?? new List<LeaderboardRecord>(0);
        [DataMember(Name="owner_records"), Preserve]
        public List<LeaderboardRecord> _ownerRecords { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<ILeaderboardRecord> Records => _records ?? new List<LeaderboardRecord>(0);
        [DataMember(Name="records"), Preserve]
        public List<LeaderboardRecord> _records { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "OwnerRecords: [", string.Join(", ", OwnerRecords), "], ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            output = string.Concat(output, "Records: [", string.Join(", ", Records), "], ");
            return output;
        }
    }

    /// <summary>
    /// Represents a realtime match.
    /// </summary>
    public interface IApiMatch
    {

        /// <summary>
        /// True if it's an server-managed authoritative match, false otherwise.
        /// </summary>
        bool Authoritative { get; }

        /// <summary>
        /// Match label, if any.
        /// </summary>
        string Label { get; }

        /// <summary>
        /// The ID of the match, can be used to join.
        /// </summary>
        string MatchId { get; }

        /// <summary>
        /// Current number of users in the match.
        /// </summary>
        int Size { get; }
    }

    /// <inheritdoc />
    internal class ApiMatch : IApiMatch
    {

        /// <inheritdoc />
        [DataMember(Name="authoritative"), Preserve]
        public bool Authoritative { get; set; }

        /// <inheritdoc />
        [DataMember(Name="label"), Preserve]
        public string Label { get; set; }

        /// <inheritdoc />
        [DataMember(Name="match_id"), Preserve]
        public string MatchId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="size"), Preserve]
        public int Size { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Authoritative: ", Authoritative, ", ");
            output = string.Concat(output, "Label: ", Label, ", ");
            output = string.Concat(output, "MatchId: ", MatchId, ", ");
            output = string.Concat(output, "Size: ", Size, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of realtime matches.
    /// </summary>
    public interface IApiMatchList
    {

        /// <summary>
        /// A number of matches corresponding to a list operation.
        /// </summary>
        IEnumerable<IMatch> Matches { get; }
    }

    /// <inheritdoc />
    internal class ApiMatchList : IApiMatchList
    {

        /// <inheritdoc />
        public IEnumerable<IMatch> Matches => _matches ?? new List<Match>(0);
        [DataMember(Name="matches"), Preserve]
        public List<Match> _matches { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Matches: [", string.Join(", ", Matches), "], ");
            return output;
        }
    }

    /// <summary>
    /// A notification in the server.
    /// </summary>
    public interface IApiNotification
    {

        /// <summary>
        /// Category code for this notification.
        /// </summary>
        int Code { get; }

        /// <summary>
        /// Content of the notification in JSON.
        /// </summary>
        string Content { get; }

        /// <summary>
        /// The UNIX time when the notification was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// ID of the Notification.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// True if this notification was persisted to the database.
        /// </summary>
        bool Persistent { get; }

        /// <summary>
        /// ID of the sender, if a user. Otherwise 'null'.
        /// </summary>
        string SenderId { get; }

        /// <summary>
        /// Subject of the notification.
        /// </summary>
        string Subject { get; }
    }

    /// <inheritdoc />
    internal class ApiNotification : IApiNotification
    {

        /// <inheritdoc />
        [DataMember(Name="code"), Preserve]
        public int Code { get; set; }

        /// <inheritdoc />
        [DataMember(Name="content"), Preserve]
        public string Content { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="persistent"), Preserve]
        public bool Persistent { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sender_id"), Preserve]
        public string SenderId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="subject"), Preserve]
        public string Subject { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Code: ", Code, ", ");
            output = string.Concat(output, "Content: ", Content, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "Persistent: ", Persistent, ", ");
            output = string.Concat(output, "SenderId: ", SenderId, ", ");
            output = string.Concat(output, "Subject: ", Subject, ", ");
            return output;
        }
    }

    /// <summary>
    /// A collection of zero or more notifications.
    /// </summary>
    public interface IApiNotificationList
    {

        /// <summary>
        /// Use this cursor to paginate notifications. Cache this to catch up to new notifications.
        /// </summary>
        string CacheableCursor { get; }

        /// <summary>
        /// Collection of notifications.
        /// </summary>
        IEnumerable<INotification> Notifications { get; }
    }

    /// <inheritdoc />
    internal class ApiNotificationList : IApiNotificationList
    {

        /// <inheritdoc />
        [DataMember(Name="cacheable_cursor"), Preserve]
        public string CacheableCursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<INotification> Notifications => _notifications ?? new List<Notification>(0);
        [DataMember(Name="notifications"), Preserve]
        public List<Notification> _notifications { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CacheableCursor: ", CacheableCursor, ", ");
            output = string.Concat(output, "Notifications: [", string.Join(", ", Notifications), "], ");
            return output;
        }
    }

    /// <summary>
    /// Storage objects to get.
    /// </summary>
    public interface IApiReadStorageObjectId
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The user owner of the object.
        /// </summary>
        string UserId { get; }
    }

    /// <inheritdoc />
    internal class ApiReadStorageObjectId : IApiReadStorageObjectId
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            return output;
        }
    }

    /// <summary>
    /// Batch get storage objects.
    /// </summary>
    public interface IApiReadStorageObjectsRequest
    {

        /// <summary>
        /// Batch of storage objects.
        /// </summary>
        IEnumerable<IReadStorageObjectId> ObjectIds { get; }
    }

    /// <inheritdoc />
    internal class ApiReadStorageObjectsRequest : IApiReadStorageObjectsRequest
    {

        /// <inheritdoc />
        public IEnumerable<IReadStorageObjectId> ObjectIds => _objectIds ?? new List<ReadStorageObjectId>(0);
        [DataMember(Name="object_ids"), Preserve]
        public List<ReadStorageObjectId> _objectIds { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "ObjectIds: [", string.Join(", ", ObjectIds), "], ");
            return output;
        }
    }

    /// <summary>
    /// Execute an Lua function on the server.
    /// </summary>
    public interface IApiRpc
    {

        /// <summary>
        /// The authentication key used when executed as a non-client HTTP request.
        /// </summary>
        string HttpKey { get; }

        /// <summary>
        /// The identifier of the function.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// The payload of the function which must be a JSON object.
        /// </summary>
        string Payload { get; }
    }

    /// <inheritdoc />
    internal class ApiRpc : IApiRpc
    {

        /// <inheritdoc />
        [DataMember(Name="http_key"), Preserve]
        public string HttpKey { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="payload"), Preserve]
        public string Payload { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "HttpKey: ", HttpKey, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "Payload: ", Payload, ", ");
            return output;
        }
    }

    /// <summary>
    /// A user's session used to authenticate messages.
    /// </summary>
    public interface IApiSession
    {

        /// <summary>
        /// True if the corresponding account was just created, false otherwise.
        /// </summary>
        bool Created { get; }

        /// <summary>
        /// Authentication credentials.
        /// </summary>
        string Token { get; }
    }

    /// <inheritdoc />
    internal class ApiSession : IApiSession
    {

        /// <inheritdoc />
        [DataMember(Name="created"), Preserve]
        public bool Created { get; set; }

        /// <inheritdoc />
        [DataMember(Name="token"), Preserve]
        public string Token { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Created: ", Created, ", ");
            output = string.Concat(output, "Token: ", Token, ", ");
            return output;
        }
    }

    /// <summary>
    /// An object within the storage engine.
    /// </summary>
    public interface IApiStorageObject
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The UNIX time when the object was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The read access permissions for the object.
        /// </summary>
        int PermissionRead { get; }

        /// <summary>
        /// The write access permissions for the object.
        /// </summary>
        int PermissionWrite { get; }

        /// <summary>
        /// The UNIX time when the object was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The user owner of the object.
        /// </summary>
        string UserId { get; }

        /// <summary>
        /// The value of the object.
        /// </summary>
        string Value { get; }

        /// <summary>
        /// The version hash of the object.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObject : IApiStorageObject
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_read"), Preserve]
        public int PermissionRead { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_write"), Preserve]
        public int PermissionWrite { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="value"), Preserve]
        public string Value { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "PermissionRead: ", PermissionRead, ", ");
            output = string.Concat(output, "PermissionWrite: ", PermissionWrite, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            output = string.Concat(output, "Value: ", Value, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// A storage acknowledgement.
    /// </summary>
    public interface IApiStorageObjectAck
    {

        /// <summary>
        /// The collection which stores the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The key of the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The owner of the object.
        /// </summary>
        string UserId { get; }

        /// <summary>
        /// The version hash of the object.
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObjectAck : IApiStorageObjectAck
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="user_id"), Preserve]
        public string UserId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "UserId: ", UserId, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// Batch of acknowledgements for the storage object write.
    /// </summary>
    public interface IApiStorageObjectAcks
    {

        /// <summary>
        /// Batch of storage write acknowledgements.
        /// </summary>
        IEnumerable<IStorageObjectAck> Acks { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObjectAcks : IApiStorageObjectAcks
    {

        /// <inheritdoc />
        public IEnumerable<IStorageObjectAck> Acks => _acks ?? new List<StorageObjectAck>(0);
        [DataMember(Name="acks"), Preserve]
        public List<StorageObjectAck> _acks { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Acks: [", string.Join(", ", Acks), "], ");
            return output;
        }
    }

    /// <summary>
    /// List of storage objects.
    /// </summary>
    public interface IApiStorageObjectList
    {

        /// <summary>
        /// The cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The list of storage objects.
        /// </summary>
        IEnumerable<IStorageObject> Objects { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObjectList : IApiStorageObjectList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<IStorageObject> Objects => _objects ?? new List<StorageObject>(0);
        [DataMember(Name="objects"), Preserve]
        public List<StorageObject> _objects { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "Objects: [", string.Join(", ", Objects), "], ");
            return output;
        }
    }

    /// <summary>
    /// Batch of storage objects.
    /// </summary>
    public interface IApiStorageObjects
    {

        /// <summary>
        /// The batch of storage objects.
        /// </summary>
        IEnumerable<IStorageObject> Objects { get; }
    }

    /// <inheritdoc />
    internal class ApiStorageObjects : IApiStorageObjects
    {

        /// <inheritdoc />
        public IEnumerable<IStorageObject> Objects => _objects ?? new List<StorageObject>(0);
        [DataMember(Name="objects"), Preserve]
        public List<StorageObject> _objects { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Objects: [", string.Join(", ", Objects), "], ");
            return output;
        }
    }

    /// <summary>
    /// A tournament on the server.
    /// </summary>
    public interface IApiTournament
    {

        /// <summary>
        /// True if the tournament is active and can enter. A computed value.
        /// </summary>
        bool CanEnter { get; }

        /// <summary>
        /// The category of the tournament. e.g. "vip" could be category 1.
        /// </summary>
        int Category { get; }

        /// <summary>
        /// The UNIX time when the tournament was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The description of the tournament. May be blank.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// Duration of the tournament in seconds.
        /// </summary>
        int Duration { get; }

        /// <summary>
        /// The UNIX time when the tournament stops being active until next reset. A computed value.
        /// </summary>
        int EndActive { get; }

        /// <summary>
        /// The UNIX time when the tournament will be stopped.
        /// </summary>
        string EndTime { get; }

        /// <summary>
        /// The ID of the tournament.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// The maximum score updates allowed per player for the current tournament.
        /// </summary>
        int MaxNumScore { get; }

        /// <summary>
        /// The maximum number of players for the tournament.
        /// </summary>
        int MaxSize { get; }

        /// <summary>
        /// Additional information stored as a JSON object.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// The UNIX time when the tournament is next playable. A computed value.
        /// </summary>
        int NextReset { get; }

        /// <summary>
        /// The current number of players in the tournament.
        /// </summary>
        int Size { get; }

        /// <summary>
        /// ASC or DESC sort mode of scores in the tournament.
        /// </summary>
        int SortOrder { get; }

        /// <summary>
        /// The UNIX time when the tournament start being active. A computed value.
        /// </summary>
        int StartActive { get; }

        /// <summary>
        /// The UNIX time when the tournament will start.
        /// </summary>
        string StartTime { get; }

        /// <summary>
        /// The title for the tournament.
        /// </summary>
        string Title { get; }
    }

    /// <inheritdoc />
    internal class ApiTournament : IApiTournament
    {

        /// <inheritdoc />
        [DataMember(Name="can_enter"), Preserve]
        public bool CanEnter { get; set; }

        /// <inheritdoc />
        [DataMember(Name="category"), Preserve]
        public int Category { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="description"), Preserve]
        public string Description { get; set; }

        /// <inheritdoc />
        [DataMember(Name="duration"), Preserve]
        public int Duration { get; set; }

        /// <inheritdoc />
        [DataMember(Name="end_active"), Preserve]
        public int EndActive { get; set; }

        /// <inheritdoc />
        [DataMember(Name="end_time"), Preserve]
        public string EndTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_num_score"), Preserve]
        public int MaxNumScore { get; set; }

        /// <inheritdoc />
        [DataMember(Name="max_size"), Preserve]
        public int MaxSize { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="next_reset"), Preserve]
        public int NextReset { get; set; }

        /// <inheritdoc />
        [DataMember(Name="size"), Preserve]
        public int Size { get; set; }

        /// <inheritdoc />
        [DataMember(Name="sort_order"), Preserve]
        public int SortOrder { get; set; }

        /// <inheritdoc />
        [DataMember(Name="start_active"), Preserve]
        public int StartActive { get; set; }

        /// <inheritdoc />
        [DataMember(Name="start_time"), Preserve]
        public string StartTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="title"), Preserve]
        public string Title { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "CanEnter: ", CanEnter, ", ");
            output = string.Concat(output, "Category: ", Category, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "Description: ", Description, ", ");
            output = string.Concat(output, "Duration: ", Duration, ", ");
            output = string.Concat(output, "EndActive: ", EndActive, ", ");
            output = string.Concat(output, "EndTime: ", EndTime, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "MaxNumScore: ", MaxNumScore, ", ");
            output = string.Concat(output, "MaxSize: ", MaxSize, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "NextReset: ", NextReset, ", ");
            output = string.Concat(output, "Size: ", Size, ", ");
            output = string.Concat(output, "SortOrder: ", SortOrder, ", ");
            output = string.Concat(output, "StartActive: ", StartActive, ", ");
            output = string.Concat(output, "StartTime: ", StartTime, ", ");
            output = string.Concat(output, "Title: ", Title, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of tournaments.
    /// </summary>
    public interface IApiTournamentList
    {

        /// <summary>
        /// A pagination cursor (optional).
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// The list of tournaments returned.
        /// </summary>
        IEnumerable<ITournament> Tournaments { get; }
    }

    /// <inheritdoc />
    internal class ApiTournamentList : IApiTournamentList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<ITournament> Tournaments => _tournaments ?? new List<Tournament>(0);
        [DataMember(Name="tournaments"), Preserve]
        public List<Tournament> _tournaments { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "Tournaments: [", string.Join(", ", Tournaments), "], ");
            return output;
        }
    }

    /// <summary>
    /// A set of tournament records which may be part of a tournament records page or a batch of individual records.
    /// </summary>
    public interface IApiTournamentRecordList
    {

        /// <summary>
        /// The cursor to send when retireving the next page (optional).
        /// </summary>
        string NextCursor { get; }

        /// <summary>
        /// A batched set of tournament records belonging to specified owners.
        /// </summary>
        IEnumerable<ILeaderboardRecord> OwnerRecords { get; }

        /// <summary>
        /// The cursor to send when retrieving the previous page (optional).
        /// </summary>
        string PrevCursor { get; }

        /// <summary>
        /// A list of tournament records.
        /// </summary>
        IEnumerable<ILeaderboardRecord> Records { get; }
    }

    /// <inheritdoc />
    internal class ApiTournamentRecordList : IApiTournamentRecordList
    {

        /// <inheritdoc />
        [DataMember(Name="next_cursor"), Preserve]
        public string NextCursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<ILeaderboardRecord> OwnerRecords => _ownerRecords ?? new List<LeaderboardRecord>(0);
        [DataMember(Name="owner_records"), Preserve]
        public List<LeaderboardRecord> _ownerRecords { get; set; }

        /// <inheritdoc />
        [DataMember(Name="prev_cursor"), Preserve]
        public string PrevCursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<ILeaderboardRecord> Records => _records ?? new List<LeaderboardRecord>(0);
        [DataMember(Name="records"), Preserve]
        public List<LeaderboardRecord> _records { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "NextCursor: ", NextCursor, ", ");
            output = string.Concat(output, "OwnerRecords: [", string.Join(", ", OwnerRecords), "], ");
            output = string.Concat(output, "PrevCursor: ", PrevCursor, ", ");
            output = string.Concat(output, "Records: [", string.Join(", ", Records), "], ");
            return output;
        }
    }

    /// <summary>
    /// Update a user's account details.
    /// </summary>
    public interface IApiUpdateAccountRequest
    {

        /// <summary>
        /// A URL for an avatar image.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// The display name of the user.
        /// </summary>
        string DisplayName { get; }

        /// <summary>
        /// The language expected to be a tag which follows the BCP-47 spec.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// The location set by the user.
        /// </summary>
        string Location { get; }

        /// <summary>
        /// The timezone set by the user.
        /// </summary>
        string Timezone { get; }

        /// <summary>
        /// The username of the user's account.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ApiUpdateAccountRequest : IApiUpdateAccountRequest
    {

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="display_name"), Preserve]
        public string DisplayName { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="location"), Preserve]
        public string Location { get; set; }

        /// <inheritdoc />
        [DataMember(Name="timezone"), Preserve]
        public string Timezone { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "DisplayName: ", DisplayName, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "Location: ", Location, ", ");
            output = string.Concat(output, "Timezone: ", Timezone, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// Update fields in a given group.
    /// </summary>
    public interface IApiUpdateGroupRequest
    {

        /// <summary>
        /// Avatar URL.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// Description string.
        /// </summary>
        string Description { get; }

        /// <summary>
        /// The ID of the group to update.
        /// </summary>
        string GroupId { get; }

        /// <summary>
        /// Lang tag.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// Name.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
        /// </summary>
        bool Open { get; }
    }

    /// <inheritdoc />
    internal class ApiUpdateGroupRequest : IApiUpdateGroupRequest
    {

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="description"), Preserve]
        public string Description { get; set; }

        /// <inheritdoc />
        [DataMember(Name="group_id"), Preserve]
        public string GroupId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="name"), Preserve]
        public string Name { get; set; }

        /// <inheritdoc />
        [DataMember(Name="open"), Preserve]
        public bool Open { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "Description: ", Description, ", ");
            output = string.Concat(output, "GroupId: ", GroupId, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "Name: ", Name, ", ");
            output = string.Concat(output, "Open: ", Open, ", ");
            return output;
        }
    }

    /// <summary>
    /// A user in the server.
    /// </summary>
    public interface IApiUser
    {

        /// <summary>
        /// A URL for an avatar image.
        /// </summary>
        string AvatarUrl { get; }

        /// <summary>
        /// The UNIX time when the user was created.
        /// </summary>
        string CreateTime { get; }

        /// <summary>
        /// The display name of the user.
        /// </summary>
        string DisplayName { get; }

        /// <summary>
        /// Number of related edges to this user.
        /// </summary>
        int EdgeCount { get; }

        /// <summary>
        /// The Facebook id in the user's account.
        /// </summary>
        string FacebookId { get; }

        /// <summary>
        /// The Apple Game Center in of the user's account.
        /// </summary>
        string GamecenterId { get; }

        /// <summary>
        /// The Google id in the user's account.
        /// </summary>
        string GoogleId { get; }

        /// <summary>
        /// The id of the user's account.
        /// </summary>
        string Id { get; }

        /// <summary>
        /// The language expected to be a tag which follows the BCP-47 spec.
        /// </summary>
        string LangTag { get; }

        /// <summary>
        /// The location set by the user.
        /// </summary>
        string Location { get; }

        /// <summary>
        /// Additional information stored as a JSON object.
        /// </summary>
        string Metadata { get; }

        /// <summary>
        /// Indicates whether the user is currently online.
        /// </summary>
        bool Online { get; }

        /// <summary>
        /// The Steam id in the user's account.
        /// </summary>
        string SteamId { get; }

        /// <summary>
        /// The timezone set by the user.
        /// </summary>
        string Timezone { get; }

        /// <summary>
        /// The UNIX time when the user was last updated.
        /// </summary>
        string UpdateTime { get; }

        /// <summary>
        /// The username of the user's account.
        /// </summary>
        string Username { get; }
    }

    /// <inheritdoc />
    internal class ApiUser : IApiUser
    {

        /// <inheritdoc />
        [DataMember(Name="avatar_url"), Preserve]
        public string AvatarUrl { get; set; }

        /// <inheritdoc />
        [DataMember(Name="create_time"), Preserve]
        public string CreateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="display_name"), Preserve]
        public string DisplayName { get; set; }

        /// <inheritdoc />
        [DataMember(Name="edge_count"), Preserve]
        public int EdgeCount { get; set; }

        /// <inheritdoc />
        [DataMember(Name="facebook_id"), Preserve]
        public string FacebookId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="gamecenter_id"), Preserve]
        public string GamecenterId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="google_id"), Preserve]
        public string GoogleId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="id"), Preserve]
        public string Id { get; set; }

        /// <inheritdoc />
        [DataMember(Name="lang_tag"), Preserve]
        public string LangTag { get; set; }

        /// <inheritdoc />
        [DataMember(Name="location"), Preserve]
        public string Location { get; set; }

        /// <inheritdoc />
        [DataMember(Name="metadata"), Preserve]
        public string Metadata { get; set; }

        /// <inheritdoc />
        [DataMember(Name="online"), Preserve]
        public bool Online { get; set; }

        /// <inheritdoc />
        [DataMember(Name="steam_id"), Preserve]
        public string SteamId { get; set; }

        /// <inheritdoc />
        [DataMember(Name="timezone"), Preserve]
        public string Timezone { get; set; }

        /// <inheritdoc />
        [DataMember(Name="update_time"), Preserve]
        public string UpdateTime { get; set; }

        /// <inheritdoc />
        [DataMember(Name="username"), Preserve]
        public string Username { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "AvatarUrl: ", AvatarUrl, ", ");
            output = string.Concat(output, "CreateTime: ", CreateTime, ", ");
            output = string.Concat(output, "DisplayName: ", DisplayName, ", ");
            output = string.Concat(output, "EdgeCount: ", EdgeCount, ", ");
            output = string.Concat(output, "FacebookId: ", FacebookId, ", ");
            output = string.Concat(output, "GamecenterId: ", GamecenterId, ", ");
            output = string.Concat(output, "GoogleId: ", GoogleId, ", ");
            output = string.Concat(output, "Id: ", Id, ", ");
            output = string.Concat(output, "LangTag: ", LangTag, ", ");
            output = string.Concat(output, "Location: ", Location, ", ");
            output = string.Concat(output, "Metadata: ", Metadata, ", ");
            output = string.Concat(output, "Online: ", Online, ", ");
            output = string.Concat(output, "SteamId: ", SteamId, ", ");
            output = string.Concat(output, "Timezone: ", Timezone, ", ");
            output = string.Concat(output, "UpdateTime: ", UpdateTime, ", ");
            output = string.Concat(output, "Username: ", Username, ", ");
            return output;
        }
    }

    /// <summary>
    /// A list of groups belonging to a user, along with the user's role in each group.
    /// </summary>
    public interface IApiUserGroupList
    {

        /// <summary>
        /// Cursor for the next page of results, if any.
        /// </summary>
        string Cursor { get; }

        /// <summary>
        /// Group-role pairs for a user.
        /// </summary>
        IEnumerable<I#/Definitions/UserGroupListUserGroup> UserGroups { get; }
    }

    /// <inheritdoc />
    internal class ApiUserGroupList : IApiUserGroupList
    {

        /// <inheritdoc />
        [DataMember(Name="cursor"), Preserve]
        public string Cursor { get; set; }

        /// <inheritdoc />
        public IEnumerable<I#/Definitions/UserGroupListUserGroup> UserGroups => _userGroups ?? new List<#/Definitions/UserGroupListUserGroup>(0);
        [DataMember(Name="user_groups"), Preserve]
        public List<#/Definitions/UserGroupListUserGroup> _userGroups { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Cursor: ", Cursor, ", ");
            output = string.Concat(output, "UserGroups: [", string.Join(", ", UserGroups), "], ");
            return output;
        }
    }

    /// <summary>
    /// A collection of zero or more users.
    /// </summary>
    public interface IApiUsers
    {

        /// <summary>
        /// The User objects.
        /// </summary>
        IEnumerable<IUser> Users { get; }
    }

    /// <inheritdoc />
    internal class ApiUsers : IApiUsers
    {

        /// <inheritdoc />
        public IEnumerable<IUser> Users => _users ?? new List<User>(0);
        [DataMember(Name="users"), Preserve]
        public List<User> _users { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Users: [", string.Join(", ", Users), "], ");
            return output;
        }
    }

    /// <summary>
    /// The object to store.
    /// </summary>
    public interface IApiWriteStorageObject
    {

        /// <summary>
        /// The collection to store the object.
        /// </summary>
        string Collection { get; }

        /// <summary>
        /// The key for the object within the collection.
        /// </summary>
        string Key { get; }

        /// <summary>
        /// The read access permissions for the object.
        /// </summary>
        int PermissionRead { get; }

        /// <summary>
        /// The write access permissions for the object.
        /// </summary>
        int PermissionWrite { get; }

        /// <summary>
        /// The value of the object.
        /// </summary>
        string Value { get; }

        /// <summary>
        /// The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
        /// </summary>
        string Version { get; }
    }

    /// <inheritdoc />
    internal class ApiWriteStorageObject : IApiWriteStorageObject
    {

        /// <inheritdoc />
        [DataMember(Name="collection"), Preserve]
        public string Collection { get; set; }

        /// <inheritdoc />
        [DataMember(Name="key"), Preserve]
        public string Key { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_read"), Preserve]
        public int PermissionRead { get; set; }

        /// <inheritdoc />
        [DataMember(Name="permission_write"), Preserve]
        public int PermissionWrite { get; set; }

        /// <inheritdoc />
        [DataMember(Name="value"), Preserve]
        public string Value { get; set; }

        /// <inheritdoc />
        [DataMember(Name="version"), Preserve]
        public string Version { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Collection: ", Collection, ", ");
            output = string.Concat(output, "Key: ", Key, ", ");
            output = string.Concat(output, "PermissionRead: ", PermissionRead, ", ");
            output = string.Concat(output, "PermissionWrite: ", PermissionWrite, ", ");
            output = string.Concat(output, "Value: ", Value, ", ");
            output = string.Concat(output, "Version: ", Version, ", ");
            return output;
        }
    }

    /// <summary>
    /// Write objects to the storage engine.
    /// </summary>
    public interface IApiWriteStorageObjectsRequest
    {

        /// <summary>
        /// The objects to store on the server.
        /// </summary>
        IEnumerable<IWriteStorageObject> Objects { get; }
    }

    /// <inheritdoc />
    internal class ApiWriteStorageObjectsRequest : IApiWriteStorageObjectsRequest
    {

        /// <inheritdoc />
        public IEnumerable<IWriteStorageObject> Objects => _objects ?? new List<WriteStorageObject>(0);
        [DataMember(Name="objects"), Preserve]
        public List<WriteStorageObject> _objects { get; set; }

        public override string ToString()
        {
            var output = "";
            output = string.Concat(output, "Objects: [", string.Join(", ", Objects), "], ");
            return output;
        }
    }

    // TOMMY
    // TOMMY
    // TOMMY
        /// A healthcheck which load balancers can use to check the service.
        ResponseFuture<> healthcheck(
        ){
            return client.healthcheck(
                HealthcheckRequest();
            );
        }
        /// Fetch the current user's account.
        ResponseFuture<Account> getAccount(
        ){
            return client.getAccount(
                GetAccountRequest();
            );
        }
        /// Update fields in the current user's account.
        ResponseFuture<> updateAccount(
              {body body true  {} { #/definitions/apiUpdateAccountRequest} },
        ){
            return client.updateAccount(
                UpdateAccountRequest();
            );
        }
        /// Authenticate a user with a custom id against the server.
        ResponseFuture<Session> authenticateCustom(
              {body body true  {} { #/definitions/apiAccountCustom} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
        ){
            return client.authenticateCustom(
                AuthenticateCustomRequest();
            );
        }
        /// Authenticate a user with a device id against the server.
        ResponseFuture<Session> authenticateDevice(
              {body body true  {} { #/definitions/apiAccountDevice} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
        ){
            return client.authenticateDevice(
                AuthenticateDeviceRequest();
            );
        }
        /// Authenticate a user with an email+password against the server.
        ResponseFuture<Session> authenticateEmail(
              {body body true  {} { #/definitions/apiAccountEmail} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
        ){
            return client.authenticateEmail(
                AuthenticateEmailRequest();
            );
        }
        /// Authenticate a user with a Facebook OAuth token against the server.
        ResponseFuture<Session> authenticateFacebook(
              {body body true  {} { #/definitions/apiAccountFacebook} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
              {sync query false boolean {} { } boolean},
        ){
            return client.authenticateFacebook(
                AuthenticateFacebookRequest();
            );
        }
        /// Authenticate a user with Apple's GameCenter against the server.
        ResponseFuture<Session> authenticateGameCenter(
              {body body true  {} { #/definitions/apiAccountGameCenter} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
        ){
            return client.authenticateGameCenter(
                AuthenticateGameCenterRequest();
            );
        }
        /// Authenticate a user with Google against the server.
        ResponseFuture<Session> authenticateGoogle(
              {body body true  {} { #/definitions/apiAccountGoogle} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
        ){
            return client.authenticateGoogle(
                AuthenticateGoogleRequest();
            );
        }
        /// Authenticate a user with Steam against the server.
        ResponseFuture<Session> authenticateSteam(
              {body body true  {} { #/definitions/apiAccountSteam} },
              {create query false boolean {} { } boolean},
              {username query false string {} { } },
        ){
            return client.authenticateSteam(
                AuthenticateSteamRequest();
            );
        }
        /// Add a custom ID to the social profiles on the current user's account.
        ResponseFuture<> linkCustom(
              {body body true  {} { #/definitions/apiAccountCustom} },
        ){
            return client.linkCustom(
                LinkCustomRequest();
            );
        }
        /// Add a device ID to the social profiles on the current user's account.
        ResponseFuture<> linkDevice(
              {body body true  {} { #/definitions/apiAccountDevice} },
        ){
            return client.linkDevice(
                LinkDeviceRequest();
            );
        }
        /// Add an email+password to the social profiles on the current user's account.
        ResponseFuture<> linkEmail(
              {body body true  {} { #/definitions/apiAccountEmail} },
        ){
            return client.linkEmail(
                LinkEmailRequest();
            );
        }
        /// Add Facebook to the social profiles on the current user's account.
        ResponseFuture<> linkFacebook(
              {body body true  {} { #/definitions/apiAccountFacebook} },
              {sync query false boolean {} { } boolean},
        ){
            return client.linkFacebook(
                LinkFacebookRequest();
            );
        }
        /// Add Apple's GameCenter to the social profiles on the current user's account.
        ResponseFuture<> linkGameCenter(
              {body body true  {} { #/definitions/apiAccountGameCenter} },
        ){
            return client.linkGameCenter(
                LinkGameCenterRequest();
            );
        }
        /// Add Google to the social profiles on the current user's account.
        ResponseFuture<> linkGoogle(
              {body body true  {} { #/definitions/apiAccountGoogle} },
        ){
            return client.linkGoogle(
                LinkGoogleRequest();
            );
        }
        /// Add Steam to the social profiles on the current user's account.
        ResponseFuture<> linkSteam(
              {body body true  {} { #/definitions/apiAccountSteam} },
        ){
            return client.linkSteam(
                LinkSteamRequest();
            );
        }
        /// Remove the custom ID from the social profiles on the current user's account.
        ResponseFuture<> unlinkCustom(
              {body body true  {} { #/definitions/apiAccountCustom} },
        ){
            return client.unlinkCustom(
                UnlinkCustomRequest();
            );
        }
        /// Remove the device ID from the social profiles on the current user's account.
        ResponseFuture<> unlinkDevice(
              {body body true  {} { #/definitions/apiAccountDevice} },
        ){
            return client.unlinkDevice(
                UnlinkDeviceRequest();
            );
        }
        /// Remove the email+password from the social profiles on the current user's account.
        ResponseFuture<> unlinkEmail(
              {body body true  {} { #/definitions/apiAccountEmail} },
        ){
            return client.unlinkEmail(
                UnlinkEmailRequest();
            );
        }
        /// Remove Facebook from the social profiles on the current user's account.
        ResponseFuture<> unlinkFacebook(
              {body body true  {} { #/definitions/apiAccountFacebook} },
        ){
            return client.unlinkFacebook(
                UnlinkFacebookRequest();
            );
        }
        /// Remove Apple's GameCenter from the social profiles on the current user's account.
        ResponseFuture<> unlinkGameCenter(
              {body body true  {} { #/definitions/apiAccountGameCenter} },
        ){
            return client.unlinkGameCenter(
                UnlinkGameCenterRequest();
            );
        }
        /// Remove Google from the social profiles on the current user's account.
        ResponseFuture<> unlinkGoogle(
              {body body true  {} { #/definitions/apiAccountGoogle} },
        ){
            return client.unlinkGoogle(
                UnlinkGoogleRequest();
            );
        }
        /// Remove Steam from the social profiles on the current user's account.
        ResponseFuture<> unlinkSteam(
              {body body true  {} { #/definitions/apiAccountSteam} },
        ){
            return client.unlinkSteam(
                UnlinkSteamRequest();
            );
        }
        /// List a channel's message history.
        ResponseFuture<ChannelMessageList> listChannelMessages(
              {channel_id path true string {} { } },
              {limit query false integer {} { } int32},
              {forward query false boolean {} { } boolean},
              {cursor query false string {} { } },
        ){
            return client.listChannelMessages(
                ListChannelMessagesRequest();
            );
        }
        /// Delete one or more users by ID or username.
        ResponseFuture<> deleteFriends(
              {ids query false array {string} { } },
              {usernames query false array {string} { } },
        ){
            return client.deleteFriends(
                DeleteFriendsRequest();
            );
        }
        /// List all friends for the current user.
        ResponseFuture<FriendList> listFriends(
              {limit query false integer {} { } int32},
              {state query false integer {} { } int32},
              {cursor query false string {} { } },
        ){
            return client.listFriends(
                ListFriendsRequest();
            );
        }
        /// Add friends by ID or username to a user's account.
        ResponseFuture<> addFriends(
              {ids query false array {string} { } },
              {usernames query false array {string} { } },
        ){
            return client.addFriends(
                AddFriendsRequest();
            );
        }
        /// Block one or more users by ID or username.
        ResponseFuture<> blockFriends(
              {ids query false array {string} { } },
              {usernames query false array {string} { } },
        ){
            return client.blockFriends(
                BlockFriendsRequest();
            );
        }
        /// Import Facebook friends and add them to a user's account.
        ResponseFuture<> importFacebookFriends(
              {body body true  {} { #/definitions/apiAccountFacebook} },
              {reset query false boolean {} { } boolean},
        ){
            return client.importFacebookFriends(
                ImportFacebookFriendsRequest();
            );
        }
        /// List groups based on given filters.
        ResponseFuture<GroupList> listGroups(
              {name query false string {} { } },
              {cursor query false string {} { } },
              {limit query false integer {} { } int32},
        ){
            return client.listGroups(
                ListGroupsRequest();
            );
        }
        /// Create a new group with the current user as the owner.
        ResponseFuture<Group> createGroup(
              {body body true  {} { #/definitions/apiCreateGroupRequest} },
        ){
            return client.createGroup(
                CreateGroupRequest();
            );
        }
        /// Delete a group by ID.
        ResponseFuture<> deleteGroup(
              {group_id path true string {} { } },
        ){
            return client.deleteGroup(
                DeleteGroupRequest();
            );
        }
        /// Update fields in a given group.
        ResponseFuture<> updateGroup(
              {group_id path true string {} { } },
              {body body true  {} { #/definitions/apiUpdateGroupRequest} },
        ){
            return client.updateGroup(
                UpdateGroupRequest();
            );
        }
        /// Add users to a group.
        ResponseFuture<> addGroupUsers(
              {group_id path true string {} { } },
              {user_ids query false array {string} { } },
        ){
            return client.addGroupUsers(
                AddGroupUsersRequest();
            );
        }
        /// Immediately join an open group, or request to join a closed one.
        ResponseFuture<> joinGroup(
              {group_id path true string {} { } },
        ){
            return client.joinGroup(
                JoinGroupRequest();
            );
        }
        /// Kick a set of users from a group.
        ResponseFuture<> kickGroupUsers(
              {group_id path true string {} { } },
              {user_ids query false array {string} { } },
        ){
            return client.kickGroupUsers(
                KickGroupUsersRequest();
            );
        }
        /// Leave a group the user is a member of.
        ResponseFuture<> leaveGroup(
              {group_id path true string {} { } },
        ){
            return client.leaveGroup(
                LeaveGroupRequest();
            );
        }
        /// Promote a set of users in a group to the next role up.
        ResponseFuture<> promoteGroupUsers(
              {group_id path true string {} { } },
              {user_ids query false array {string} { } },
        ){
            return client.promoteGroupUsers(
                PromoteGroupUsersRequest();
            );
        }
        /// List all users that are part of a group.
        ResponseFuture<GroupUserList> listGroupUsers(
              {group_id path true string {} { } },
              {limit query false integer {} { } int32},
              {state query false integer {} { } int32},
              {cursor query false string {} { } },
        ){
            return client.listGroupUsers(
                ListGroupUsersRequest();
            );
        }
        /// Delete a leaderboard record.
        ResponseFuture<> deleteLeaderboardRecord(
              {leaderboard_id path true string {} { } },
        ){
            return client.deleteLeaderboardRecord(
                DeleteLeaderboardRecordRequest();
            );
        }
        /// List leaderboard records.
        ResponseFuture<LeaderboardRecordList> listLeaderboardRecords(
              {leaderboard_id path true string {} { } },
              {owner_ids query false array {string} { } },
              {limit query false integer {} { } int32},
              {cursor query false string {} { } },
              {expiry query false string {} { } int64},
        ){
            return client.listLeaderboardRecords(
                ListLeaderboardRecordsRequest();
            );
        }
        /// Write a record to a leaderboard.
        ResponseFuture<LeaderboardRecord> writeLeaderboardRecord(
              {leaderboard_id path true string {} { } },
              {body body true  {} { #/definitions/WriteLeaderboardRecordRequestLeaderboardRecordWrite} },
        ){
            return client.writeLeaderboardRecord(
                WriteLeaderboardRecordRequest();
            );
        }
        /// List leaderboard records that belong to a user.
        ResponseFuture<LeaderboardRecordList> listLeaderboardRecordsAroundOwner(
              {leaderboard_id path true string {} { } },
              {owner_id path true string {} { } },
              {limit query false integer {} { } int64},
              {expiry query false string {} { } int64},
        ){
            return client.listLeaderboardRecordsAroundOwner(
                ListLeaderboardRecordsAroundOwnerRequest();
            );
        }
        /// Fetch list of running matches.
        ResponseFuture<MatchList> listMatches(
              {limit query false integer {} { } int32},
              {authoritative query false boolean {} { } boolean},
              {label query false string {} { } },
              {min_size query false integer {} { } int32},
              {max_size query false integer {} { } int32},
              {query query false string {} { } },
        ){
            return client.listMatches(
                ListMatchesRequest();
            );
        }
        /// Delete one or more notifications for the current user.
        ResponseFuture<> deleteNotifications(
              {ids query false array {string} { } },
        ){
            return client.deleteNotifications(
                DeleteNotificationsRequest();
            );
        }
        /// Fetch list of notifications.
        ResponseFuture<NotificationList> listNotifications(
              {limit query false integer {} { } int32},
              {cacheable_cursor query false string {} { } },
        ){
            return client.listNotifications(
                ListNotificationsRequest();
            );
        }
        /// Execute a Lua function on the server.
        ResponseFuture<Rpc> rpcFunc2(
              {id path true string {} { } },
              {payload query false string {} { } },
              {http_key query false string {} { } },
        ){
            return client.rpcFunc2(
                RpcFunc2Request();
            );
        }
        /// Execute a Lua function on the server.
        ResponseFuture<Rpc> rpcFunc(
              {id path true string {} { } },
              {body body true  {} {string } },
        ){
            return client.rpcFunc(
                RpcFuncRequest();
            );
        }
        /// Get storage objects.
        ResponseFuture<StorageObjects> readStorageObjects(
              {body body true  {} { #/definitions/apiReadStorageObjectsRequest} },
        ){
            return client.readStorageObjects(
                ReadStorageObjectsRequest();
            );
        }
        /// Write objects into the storage engine.
        ResponseFuture<StorageObjectAcks> writeStorageObjects(
              {body body true  {} { #/definitions/apiWriteStorageObjectsRequest} },
        ){
            return client.writeStorageObjects(
                WriteStorageObjectsRequest();
            );
        }
        /// Delete one or more objects by ID or username.
        ResponseFuture<> deleteStorageObjects(
              {body body true  {} { #/definitions/apiDeleteStorageObjectsRequest} },
        ){
            return client.deleteStorageObjects(
                DeleteStorageObjectsRequest();
            );
        }
        /// List publicly readable storage objects in a given collection.
        ResponseFuture<StorageObjectList> listStorageObjects(
              {collection path true string {} { } },
              {user_id query false string {} { } },
              {limit query false integer {} { } int32},
              {cursor query false string {} { } },
        ){
            return client.listStorageObjects(
                ListStorageObjectsRequest();
            );
        }
        /// List publicly readable storage objects in a given collection.
        ResponseFuture<StorageObjectList> listStorageObjects2(
              {collection path true string {} { } },
              {user_id path true string {} { } },
              {limit query false integer {} { } int32},
              {cursor query false string {} { } },
        ){
            return client.listStorageObjects2(
                ListStorageObjects2Request();
            );
        }
        /// List current or upcoming tournaments.
        ResponseFuture<TournamentList> listTournaments(
              {category_start query false integer {} { } int64},
              {category_end query false integer {} { } int64},
              {start_time query false integer {} { } int64},
              {end_time query false integer {} { } int64},
              {limit query false integer {} { } int32},
              {cursor query false string {} { } },
        ){
            return client.listTournaments(
                ListTournamentsRequest();
            );
        }
        /// List tournament records.
        ResponseFuture<TournamentRecordList> listTournamentRecords(
              {tournament_id path true string {} { } },
              {owner_ids query false array {string} { } },
              {limit query false integer {} { } int32},
              {cursor query false string {} { } },
              {expiry query false string {} { } int64},
        ){
            return client.listTournamentRecords(
                ListTournamentRecordsRequest();
            );
        }
        /// Write a record to a tournament.
        ResponseFuture<LeaderboardRecord> writeTournamentRecord(
              {tournament_id path true string {} { } },
              {body body true  {} { #/definitions/WriteTournamentRecordRequestTournamentRecordWrite} },
        ){
            return client.writeTournamentRecord(
                WriteTournamentRecordRequest();
            );
        }
        /// Attempt to join an open and running tournament.
        ResponseFuture<> joinTournament(
              {tournament_id path true string {} { } },
        ){
            return client.joinTournament(
                JoinTournamentRequest();
            );
        }
        /// List tournament records for a given owner.
        ResponseFuture<TournamentRecordList> listTournamentRecordsAroundOwner(
              {tournament_id path true string {} { } },
              {owner_id path true string {} { } },
              {limit query false integer {} { } int64},
              {expiry query false string {} { } int64},
        ){
            return client.listTournamentRecordsAroundOwner(
                ListTournamentRecordsAroundOwnerRequest();
            );
        }
        /// Fetch zero or more users by ID and/or username.
        ResponseFuture<Users> getUsers(
              {ids query false array {string} { } },
              {usernames query false array {string} { } },
              {facebook_ids query false array {string} { } },
        ){
            return client.getUsers(
                GetUsersRequest();
            );
        }
        /// List groups the current user belongs to.
        ResponseFuture<UserGroupList> listUserGroups(
              {user_id path true string {} { } },
              {limit query false integer {} { } int32},
              {state query false integer {} { } int32},
              {cursor query false string {} { } },
        ){
            return client.listUserGroups(
                ListUserGroupsRequest();
            );
        }

    /// <summary>
    /// The low level client for the Nakama API.
    /// </summary>
    internal class ApiClient
    {
        private readonly Uri _baseUri;
        private readonly int _timeout;
        public readonly IHttpAdapter HttpAdapter;

        public ApiClient(Uri baseUri, IHttpAdapter httpAdapter, int timeout = 10)
        {
            _baseUri = baseUri;
            _timeout = timeout;
            HttpAdapter = httpAdapter;
        }

        /// <summary>
        /// A healthcheck which load balancers can use to check the service.
        /// </summary>
        public async Task HealthcheckAsync(
            string bearerToken)
        {

            var urlpath = "/healthcheck";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Fetch the current user's account.
        /// </summary>
        public async Task<IAccount> GetAccountAsync(
            string bearerToken)
        {

            var urlpath = "/v2/account";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Account>();
        }

        /// <summary>
        /// Update fields in the current user's account.
        /// </summary>
        public async Task UpdateAccountAsync(
            string bearerToken,
            UpdateAccountRequest body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "PUT";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Authenticate a user with a custom id against the server.
        /// </summary>
        public async Task<ISession> AuthenticateCustomAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountCustom body,
            bool? create,
            string username)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/custom";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Authenticate a user with a device id against the server.
        /// </summary>
        public async Task<ISession> AuthenticateDeviceAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountDevice body,
            bool? create,
            string username)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/device";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Authenticate a user with an email+password against the server.
        /// </summary>
        public async Task<ISession> AuthenticateEmailAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountEmail body,
            bool? create,
            string username)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/email";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Authenticate a user with a Facebook OAuth token against the server.
        /// </summary>
        public async Task<ISession> AuthenticateFacebookAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountFacebook body,
            bool? create,
            string username,
            bool? sync)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/facebook";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }
            if (sync != null) {
                queryParams = string.Concat(queryParams, "sync=", sync.ToString().ToLower(), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Authenticate a user with Apple's GameCenter against the server.
        /// </summary>
        public async Task<ISession> AuthenticateGameCenterAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountGameCenter body,
            bool? create,
            string username)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/gamecenter";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Authenticate a user with Google against the server.
        /// </summary>
        public async Task<ISession> AuthenticateGoogleAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountGoogle body,
            bool? create,
            string username)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/google";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Authenticate a user with Steam against the server.
        /// </summary>
        public async Task<ISession> AuthenticateSteamAsync(
            string basicAuthUsername,
            string basicAuthPassword,
            AccountSteam body,
            bool? create,
            string username)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/authenticate/steam";

            var queryParams = "";
            if (create != null) {
                queryParams = string.Concat(queryParams, "create=", create.ToString().ToLower(), "&");
            }
            if (username != null) {
                queryParams = string.Concat(queryParams, "username=", Uri.EscapeDataString(username), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var credentials = Encoding.UTF8.GetBytes(basicAuthUsername + ":" + basicAuthPassword);
            var header = string.Concat("Basic ", Convert.ToBase64String(credentials));
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Session>();
        }

        /// <summary>
        /// Add a custom ID to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkCustomAsync(
            string bearerToken,
            AccountCustom body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/custom";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add a device ID to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkDeviceAsync(
            string bearerToken,
            AccountDevice body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/device";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add an email+password to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkEmailAsync(
            string bearerToken,
            AccountEmail body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/email";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add Facebook to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkFacebookAsync(
            string bearerToken,
            AccountFacebook body,
            bool? sync)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/facebook";

            var queryParams = "";
            if (sync != null) {
                queryParams = string.Concat(queryParams, "sync=", sync.ToString().ToLower(), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add Apple's GameCenter to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkGameCenterAsync(
            string bearerToken,
            AccountGameCenter body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/gamecenter";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add Google to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkGoogleAsync(
            string bearerToken,
            AccountGoogle body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/google";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add Steam to the social profiles on the current user's account.
        /// </summary>
        public async Task LinkSteamAsync(
            string bearerToken,
            AccountSteam body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/link/steam";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove the custom ID from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkCustomAsync(
            string bearerToken,
            AccountCustom body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/custom";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove the device ID from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkDeviceAsync(
            string bearerToken,
            AccountDevice body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/device";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove the email+password from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkEmailAsync(
            string bearerToken,
            AccountEmail body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/email";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove Facebook from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkFacebookAsync(
            string bearerToken,
            AccountFacebook body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/facebook";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove Apple's GameCenter from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkGameCenterAsync(
            string bearerToken,
            AccountGameCenter body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/gamecenter";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove Google from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkGoogleAsync(
            string bearerToken,
            AccountGoogle body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/google";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Remove Steam from the social profiles on the current user's account.
        /// </summary>
        public async Task UnlinkSteamAsync(
            string bearerToken,
            AccountSteam body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/account/unlink/steam";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List a channel's message history.
        /// </summary>
        public async Task<IChannelMessageList> ListChannelMessagesAsync(
            string bearerToken,
            string channel_id,
            int? limit,
            bool? forward,
            string cursor)
        {
            if (channelId == null)
            {
                throw new ArgumentException("'channelId' is required but was null.");
            }

            var urlpath = "/v2/channel/{channel_id}";
            urlpath = urlpath.Replace("{channel_id}", Uri.EscapeDataString(channel_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (forward != null) {
                queryParams = string.Concat(queryParams, "forward=", forward.ToString().ToLower(), "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<ChannelMessageList>();
        }

        /// <summary>
        /// Delete one or more users by ID or username.
        /// </summary>
        public async Task DeleteFriendsAsync(
            string bearerToken,
            IEnumerable<string> ids,
            IEnumerable<string> usernames)
        {

            var urlpath = "/v2/friend";

            var queryParams = "";
            foreach (var elem in ids ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "ids=", elem, "&");
            }
            foreach (var elem in usernames ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "usernames=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List all friends for the current user.
        /// </summary>
        public async Task<IFriendList> ListFriendsAsync(
            string bearerToken,
            int? limit,
            int? state,
            string cursor)
        {

            var urlpath = "/v2/friend";

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (state != null) {
                queryParams = string.Concat(queryParams, "state=", state, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<FriendList>();
        }

        /// <summary>
        /// Add friends by ID or username to a user's account.
        /// </summary>
        public async Task AddFriendsAsync(
            string bearerToken,
            IEnumerable<string> ids,
            IEnumerable<string> usernames)
        {

            var urlpath = "/v2/friend";

            var queryParams = "";
            foreach (var elem in ids ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "ids=", elem, "&");
            }
            foreach (var elem in usernames ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "usernames=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Block one or more users by ID or username.
        /// </summary>
        public async Task BlockFriendsAsync(
            string bearerToken,
            IEnumerable<string> ids,
            IEnumerable<string> usernames)
        {

            var urlpath = "/v2/friend/block";

            var queryParams = "";
            foreach (var elem in ids ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "ids=", elem, "&");
            }
            foreach (var elem in usernames ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "usernames=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Import Facebook friends and add them to a user's account.
        /// </summary>
        public async Task ImportFacebookFriendsAsync(
            string bearerToken,
            AccountFacebook body,
            bool? reset)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/friend/facebook";

            var queryParams = "";
            if (reset != null) {
                queryParams = string.Concat(queryParams, "reset=", reset.ToString().ToLower(), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List groups based on given filters.
        /// </summary>
        public async Task<IGroupList> ListGroupsAsync(
            string bearerToken,
            string name,
            string cursor,
            int? limit)
        {

            var urlpath = "/v2/group";

            var queryParams = "";
            if (name != null) {
                queryParams = string.Concat(queryParams, "name=", Uri.EscapeDataString(name), "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<GroupList>();
        }

        /// <summary>
        /// Create a new group with the current user as the owner.
        /// </summary>
        public async Task<IGroup> CreateGroupAsync(
            string bearerToken,
            CreateGroupRequest body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/group";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Group>();
        }

        /// <summary>
        /// Delete a group by ID.
        /// </summary>
        public async Task DeleteGroupAsync(
            string bearerToken,
            string group_id)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Update fields in a given group.
        /// </summary>
        public async Task UpdateGroupAsync(
            string bearerToken,
            string group_id,
            UpdateGroupRequest body)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "PUT";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Add users to a group.
        /// </summary>
        public async Task AddGroupUsersAsync(
            string bearerToken,
            string group_id,
            IEnumerable<string> userIds)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}/add";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";
            foreach (var elem in userIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "user_ids=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Immediately join an open group, or request to join a closed one.
        /// </summary>
        public async Task JoinGroupAsync(
            string bearerToken,
            string group_id)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}/join";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Kick a set of users from a group.
        /// </summary>
        public async Task KickGroupUsersAsync(
            string bearerToken,
            string group_id,
            IEnumerable<string> userIds)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}/kick";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";
            foreach (var elem in userIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "user_ids=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Leave a group the user is a member of.
        /// </summary>
        public async Task LeaveGroupAsync(
            string bearerToken,
            string group_id)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}/leave";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Promote a set of users in a group to the next role up.
        /// </summary>
        public async Task PromoteGroupUsersAsync(
            string bearerToken,
            string group_id,
            IEnumerable<string> userIds)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}/promote";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";
            foreach (var elem in userIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "user_ids=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List all users that are part of a group.
        /// </summary>
        public async Task<IGroupUserList> ListGroupUsersAsync(
            string bearerToken,
            string group_id,
            int? limit,
            int? state,
            string cursor)
        {
            if (groupId == null)
            {
                throw new ArgumentException("'groupId' is required but was null.");
            }

            var urlpath = "/v2/group/{group_id}/user";
            urlpath = urlpath.Replace("{group_id}", Uri.EscapeDataString(group_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (state != null) {
                queryParams = string.Concat(queryParams, "state=", state, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<GroupUserList>();
        }

        /// <summary>
        /// Delete a leaderboard record.
        /// </summary>
        public async Task DeleteLeaderboardRecordAsync(
            string bearerToken,
            string leaderboard_id)
        {
            if (leaderboardId == null)
            {
                throw new ArgumentException("'leaderboardId' is required but was null.");
            }

            var urlpath = "/v2/leaderboard/{leaderboard_id}";
            urlpath = urlpath.Replace("{leaderboard_id}", Uri.EscapeDataString(leaderboard_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List leaderboard records.
        /// </summary>
        public async Task<ILeaderboardRecordList> ListLeaderboardRecordsAsync(
            string bearerToken,
            string leaderboard_id,
            IEnumerable<string> ownerIds,
            int? limit,
            string cursor,
            string expiry)
        {
            if (leaderboardId == null)
            {
                throw new ArgumentException("'leaderboardId' is required but was null.");
            }

            var urlpath = "/v2/leaderboard/{leaderboard_id}";
            urlpath = urlpath.Replace("{leaderboard_id}", Uri.EscapeDataString(leaderboard_id));

            var queryParams = "";
            foreach (var elem in ownerIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "owner_ids=", elem, "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }
            if (expiry != null) {
                queryParams = string.Concat(queryParams, "expiry=", Uri.EscapeDataString(expiry), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<LeaderboardRecordList>();
        }

        /// <summary>
        /// Write a record to a leaderboard.
        /// </summary>
        public async Task<ILeaderboardRecord> WriteLeaderboardRecordAsync(
            string bearerToken,
            string leaderboard_id,
            #/Definitions/WriteLeaderboardRecordRequestLeaderboardRecordWrite body)
        {
            if (leaderboardId == null)
            {
                throw new ArgumentException("'leaderboardId' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/leaderboard/{leaderboard_id}";
            urlpath = urlpath.Replace("{leaderboard_id}", Uri.EscapeDataString(leaderboard_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<LeaderboardRecord>();
        }

        /// <summary>
        /// List leaderboard records that belong to a user.
        /// </summary>
        public async Task<ILeaderboardRecordList> ListLeaderboardRecordsAroundOwnerAsync(
            string bearerToken,
            string leaderboard_id,
            string owner_id,
            int? limit,
            string expiry)
        {
            if (leaderboardId == null)
            {
                throw new ArgumentException("'leaderboardId' is required but was null.");
            }
            if (ownerId == null)
            {
                throw new ArgumentException("'ownerId' is required but was null.");
            }

            var urlpath = "/v2/leaderboard/{leaderboard_id}/owner/{owner_id}";
            urlpath = urlpath.Replace("{leaderboard_id}", Uri.EscapeDataString(leaderboard_id));
            urlpath = urlpath.Replace("{owner_id}", Uri.EscapeDataString(owner_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (expiry != null) {
                queryParams = string.Concat(queryParams, "expiry=", Uri.EscapeDataString(expiry), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<LeaderboardRecordList>();
        }

        /// <summary>
        /// Fetch list of running matches.
        /// </summary>
        public async Task<IMatchList> ListMatchesAsync(
            string bearerToken,
            int? limit,
            bool? authoritative,
            string label,
            int? min_size,
            int? max_size,
            string query)
        {

            var urlpath = "/v2/match";

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (authoritative != null) {
                queryParams = string.Concat(queryParams, "authoritative=", authoritative.ToString().ToLower(), "&");
            }
            if (label != null) {
                queryParams = string.Concat(queryParams, "label=", Uri.EscapeDataString(label), "&");
            }
            if (min_size != null) {
                queryParams = string.Concat(queryParams, "min_size=", min_size, "&");
            }
            if (max_size != null) {
                queryParams = string.Concat(queryParams, "max_size=", max_size, "&");
            }
            if (query != null) {
                queryParams = string.Concat(queryParams, "query=", Uri.EscapeDataString(query), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<MatchList>();
        }

        /// <summary>
        /// Delete one or more notifications for the current user.
        /// </summary>
        public async Task DeleteNotificationsAsync(
            string bearerToken,
            IEnumerable<string> ids)
        {

            var urlpath = "/v2/notification";

            var queryParams = "";
            foreach (var elem in ids ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "ids=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "DELETE";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// Fetch list of notifications.
        /// </summary>
        public async Task<INotificationList> ListNotificationsAsync(
            string bearerToken,
            int? limit,
            string cacheable_cursor)
        {

            var urlpath = "/v2/notification";

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cacheable_cursor != null) {
                queryParams = string.Concat(queryParams, "cacheable_cursor=", Uri.EscapeDataString(cacheable_cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<NotificationList>();
        }

        /// <summary>
        /// Execute a Lua function on the server.
        /// </summary>
        public async Task<IRpc> RpcFunc2Async(
            string bearerToken,
            string id,
            string payload,
            string http_key)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }

            var urlpath = "/v2/rpc/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";
            if (payload != null) {
                queryParams = string.Concat(queryParams, "payload=", Uri.EscapeDataString(payload), "&");
            }
            if (http_key != null) {
                queryParams = string.Concat(queryParams, "http_key=", Uri.EscapeDataString(http_key), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(bearerToken))
            {
                var header = string.Concat("Bearer ", bearerToken);
                headers.Add("Authorization", header);
            }

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Rpc>();
        }

        /// <summary>
        /// Execute a Lua function on the server.
        /// </summary>
        public async Task<IRpc> RpcFuncAsync(
            string bearerToken,
            string id,
            string body)
        {
            if (id == null)
            {
                throw new ArgumentException("'id' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/rpc/{id}";
            urlpath = urlpath.Replace("{id}", Uri.EscapeDataString(id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(bearerToken))
            {
                var header = string.Concat("Bearer ", bearerToken);
                headers.Add("Authorization", header);
            }

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Rpc>();
        }

        /// <summary>
        /// Get storage objects.
        /// </summary>
        public async Task<IStorageObjects> ReadStorageObjectsAsync(
            string bearerToken,
            ReadStorageObjectsRequest body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/storage";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<StorageObjects>();
        }

        /// <summary>
        /// Write objects into the storage engine.
        /// </summary>
        public async Task<IStorageObjectAcks> WriteStorageObjectsAsync(
            string bearerToken,
            WriteStorageObjectsRequest body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/storage";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "PUT";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<StorageObjectAcks>();
        }

        /// <summary>
        /// Delete one or more objects by ID or username.
        /// </summary>
        public async Task DeleteStorageObjectsAsync(
            string bearerToken,
            DeleteStorageObjectsRequest body)
        {
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/storage/delete";

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "PUT";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List publicly readable storage objects in a given collection.
        /// </summary>
        public async Task<IStorageObjectList> ListStorageObjectsAsync(
            string bearerToken,
            string collection,
            string user_id,
            int? limit,
            string cursor)
        {
            if (collection == null)
            {
                throw new ArgumentException("'collection' is required but was null.");
            }

            var urlpath = "/v2/storage/{collection}";
            urlpath = urlpath.Replace("{collection}", Uri.EscapeDataString(collection));

            var queryParams = "";
            if (user_id != null) {
                queryParams = string.Concat(queryParams, "user_id=", Uri.EscapeDataString(user_id), "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<StorageObjectList>();
        }

        /// <summary>
        /// List publicly readable storage objects in a given collection.
        /// </summary>
        public async Task<IStorageObjectList> ListStorageObjects2Async(
            string bearerToken,
            string collection,
            string user_id,
            int? limit,
            string cursor)
        {
            if (collection == null)
            {
                throw new ArgumentException("'collection' is required but was null.");
            }
            if (userId == null)
            {
                throw new ArgumentException("'userId' is required but was null.");
            }

            var urlpath = "/v2/storage/{collection}/{user_id}";
            urlpath = urlpath.Replace("{collection}", Uri.EscapeDataString(collection));
            urlpath = urlpath.Replace("{user_id}", Uri.EscapeDataString(user_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<StorageObjectList>();
        }

        /// <summary>
        /// List current or upcoming tournaments.
        /// </summary>
        public async Task<ITournamentList> ListTournamentsAsync(
            string bearerToken,
            int? category_start,
            int? category_end,
            int? start_time,
            int? end_time,
            int? limit,
            string cursor)
        {

            var urlpath = "/v2/tournament";

            var queryParams = "";
            if (category_start != null) {
                queryParams = string.Concat(queryParams, "category_start=", category_start, "&");
            }
            if (category_end != null) {
                queryParams = string.Concat(queryParams, "category_end=", category_end, "&");
            }
            if (start_time != null) {
                queryParams = string.Concat(queryParams, "start_time=", start_time, "&");
            }
            if (end_time != null) {
                queryParams = string.Concat(queryParams, "end_time=", end_time, "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<TournamentList>();
        }

        /// <summary>
        /// List tournament records.
        /// </summary>
        public async Task<ITournamentRecordList> ListTournamentRecordsAsync(
            string bearerToken,
            string tournament_id,
            IEnumerable<string> ownerIds,
            int? limit,
            string cursor,
            string expiry)
        {
            if (tournamentId == null)
            {
                throw new ArgumentException("'tournamentId' is required but was null.");
            }

            var urlpath = "/v2/tournament/{tournament_id}";
            urlpath = urlpath.Replace("{tournament_id}", Uri.EscapeDataString(tournament_id));

            var queryParams = "";
            foreach (var elem in ownerIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "owner_ids=", elem, "&");
            }
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }
            if (expiry != null) {
                queryParams = string.Concat(queryParams, "expiry=", Uri.EscapeDataString(expiry), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<TournamentRecordList>();
        }

        /// <summary>
        /// Write a record to a tournament.
        /// </summary>
        public async Task<ILeaderboardRecord> WriteTournamentRecordAsync(
            string bearerToken,
            string tournament_id,
            #/Definitions/WriteTournamentRecordRequestTournamentRecordWrite body)
        {
            if (tournamentId == null)
            {
                throw new ArgumentException("'tournamentId' is required but was null.");
            }
            if (body == null)
            {
                throw new ArgumentException("'body' is required but was null.");
            }

            var urlpath = "/v2/tournament/{tournament_id}";
            urlpath = urlpath.Replace("{tournament_id}", Uri.EscapeDataString(tournament_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "PUT";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var jsonBody = body.ToJson();
            content = Encoding.UTF8.GetBytes(jsonBody);
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<LeaderboardRecord>();
        }

        /// <summary>
        /// Attempt to join an open and running tournament.
        /// </summary>
        public async Task JoinTournamentAsync(
            string bearerToken,
            string tournament_id)
        {
            if (tournamentId == null)
            {
                throw new ArgumentException("'tournamentId' is required but was null.");
            }

            var urlpath = "/v2/tournament/{tournament_id}/join";
            urlpath = urlpath.Replace("{tournament_id}", Uri.EscapeDataString(tournament_id));

            var queryParams = "";

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "POST";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
        }

        /// <summary>
        /// List tournament records for a given owner.
        /// </summary>
        public async Task<ITournamentRecordList> ListTournamentRecordsAroundOwnerAsync(
            string bearerToken,
            string tournament_id,
            string owner_id,
            int? limit,
            string expiry)
        {
            if (tournamentId == null)
            {
                throw new ArgumentException("'tournamentId' is required but was null.");
            }
            if (ownerId == null)
            {
                throw new ArgumentException("'ownerId' is required but was null.");
            }

            var urlpath = "/v2/tournament/{tournament_id}/owner/{owner_id}";
            urlpath = urlpath.Replace("{tournament_id}", Uri.EscapeDataString(tournament_id));
            urlpath = urlpath.Replace("{owner_id}", Uri.EscapeDataString(owner_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (expiry != null) {
                queryParams = string.Concat(queryParams, "expiry=", Uri.EscapeDataString(expiry), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<TournamentRecordList>();
        }

        /// <summary>
        /// Fetch zero or more users by ID and/or username.
        /// </summary>
        public async Task<IUsers> GetUsersAsync(
            string bearerToken,
            IEnumerable<string> ids,
            IEnumerable<string> usernames,
            IEnumerable<string> facebookIds)
        {

            var urlpath = "/v2/user";

            var queryParams = "";
            foreach (var elem in ids ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "ids=", elem, "&");
            }
            foreach (var elem in usernames ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "usernames=", elem, "&");
            }
            foreach (var elem in facebookIds ?? new string[0])
            {
                queryParams = string.Concat(queryParams, "facebook_ids=", elem, "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<Users>();
        }

        /// <summary>
        /// List groups the current user belongs to.
        /// </summary>
        public async Task<IUserGroupList> ListUserGroupsAsync(
            string bearerToken,
            string user_id,
            int? limit,
            int? state,
            string cursor)
        {
            if (userId == null)
            {
                throw new ArgumentException("'userId' is required but was null.");
            }

            var urlpath = "/v2/user/{user_id}/group";
            urlpath = urlpath.Replace("{user_id}", Uri.EscapeDataString(user_id));

            var queryParams = "";
            if (limit != null) {
                queryParams = string.Concat(queryParams, "limit=", limit, "&");
            }
            if (state != null) {
                queryParams = string.Concat(queryParams, "state=", state, "&");
            }
            if (cursor != null) {
                queryParams = string.Concat(queryParams, "cursor=", Uri.EscapeDataString(cursor), "&");
            }

            var uri = new UriBuilder(_baseUri)
            {
                Path = urlpath,
                Query = queryParams
            }.Uri;

            var method = "GET";
            var headers = new Dictionary<string, string>();
            var header = string.Concat("Bearer ", bearerToken);
            headers.Add("Authorization", header);

            byte[] content = null;
            var contents = await HttpAdapter.SendAsync(method, uri, headers, content, _timeout);
            return contents.FromJson<UserGroupList>();
        }
    }
}
